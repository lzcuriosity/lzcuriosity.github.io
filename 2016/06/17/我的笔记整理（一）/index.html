<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      我的笔记整理（一） | Zen3’s blog 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Zen3">
    
    

    <meta name="description" content="前言这应该会成为一个系列博文吧，之前就想过要陆陆续续把自己以前学习记录在印象笔记里的一些东西整合一下，然后发出来。都是一些比较零散的但又挺重要的吧，如果对别人也有所帮助，那倒是一件美事，没有的话，留给自己复习也不错~">
<meta property="og:type" content="article">
<meta property="og:title" content="我的笔记整理（一） | Zen3’s blog">
<meta property="og:url" content="http://yoursite.com/2016/06/17/我的笔记整理（一）/index.html">
<meta property="og:site_name" content="Zen3’s blog">
<meta property="og:description" content="前言这应该会成为一个系列博文吧，之前就想过要陆陆续续把自己以前学习记录在印象笔记里的一些东西整合一下，然后发出来。都是一些比较零散的但又挺重要的吧，如果对别人也有所帮助，那倒是一件美事，没有的话，留给自己复习也不错~">
<meta property="og:updated_time" content="2016-07-10T02:34:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="我的笔记整理（一） | Zen3’s blog">
<meta name="twitter:description" content="前言这应该会成为一个系列博文吧，之前就想过要陆陆续续把自己以前学习记录在印象笔记里的一些东西整合一下，然后发出来。都是一些比较零散的但又挺重要的吧，如果对别人也有所帮助，那倒是一件美事，没有的话，留给自己复习也不错~">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Zen3’s blog</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          Be a Mr.Curiosity for coding.
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



<nav class="cover-navigation navigation--social">
  <ul class="navigation">

    
      <!-- Github -->
      <li class="navigation__item">
        <a href="https://github.com/lzcuriosity" title="Huno on GitHub">
          <i class='icon icon-social-github'></i>
          <span class="label">GitHub</span>
        </a>
      </li>
    

   
      <!-- Instagram -->
      <li class="navigation__item">
        <a href="https://www.instagram.com/lzcuriosity" title="Huno on Instagram">
          <i class='icon icon-social-instagram'></i>
          <span class="label">Instagram </span>
        </a>
      </li>
    

    <!-- China social icon -->
    <!--
    
      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-douban'></i>
          <span class="label">Douban</span>
        </a>
      </li>

      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-weibo'></i>
          <span class="label">Weibo</span>
        </a>
      </li>

    -->



  </ul>
</nav>



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">我的笔记整理（一）</h1>

    

    <div class="post-meta">
      <time datetime="2016-06-17" class="post-meta__date date">2016-06-17</time> 

      <span class="post-meta__tags tags">

          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/iOS/">iOS</a>, <a class="tags-link" href="/tags/笔记/">笔记</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这应该会成为一个系列博文吧，之前就想过要陆陆续续把自己以前学习记录在印象笔记里的一些东西整合一下，然后发出来。都是一些比较零散的但又挺重要的吧，如果对别人也有所帮助，那倒是一件美事，没有的话，留给自己复习也不错~<br><a id="more"></a></p>
<h2 id="实例变量与属性"><a href="#实例变量与属性" class="headerlink" title="实例变量与属性"></a>实例变量与属性</h2><p>这个是我一开始学习 Objc 比较纠结的问题了。对于一个普通的类，我们去定义一个<code>属性</code>,例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br></pre></td></tr></table></figure>
<p>和我们这样去定义一个<code>实例变量</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>究竟有什么区别？</p>
<p>在网上看到一些文章在解释主要的区别是说使用 <strong>@property</strong> 关键字的属性可以被其他类所访问、修改；而写在大括号里的实例变量却不能被其他类所访问。</p>
<p>其实不然。</p>
<p>之所以会有这样的结论，是因为我们在定义实例变量的时候往往忽略了他的关键字声明，类似于 C++ 实例变量的定义是有以下3种关键字的：</p>
<ul>
<li><p>@private 私有成员，只有当前类可以访问；</p>
</li>
<li><p>@protected 受保护成员，只有当前类或子类可以访问（如果没有添加任何修饰则默认为@protected）；</p>
</li>
<li><p>@public 公共成员，所有类均可访问；(公共成员的调用使用<code>“-&gt;”</code>操作符；)</p>
</li>
</ul>
<p>所以像刚刚上面的代码，实例变量就默认设置为 <code>protected</code> ,所以除了子类的其他类午饭访问到实例变量 <strong>name</strong>。</p>
<p>所以，实例变量和属性之间的区别肯定不是在这里。</p>
<p>我觉得，通俗一点讲：</p>
<p><strong>实例变量 + getter 与 setter 方法 = 属性</strong></p>
<p>例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义方法设置属性值(注意是setXxx)</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义方法的获取属性值(注意不是getXxx,而是直接的属性名，因为getXXX在 OC 中还有其他用途)</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)name;</span><br></pre></td></tr></table></figure>
<p>又在 .m文件里完成函数的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    <span class="keyword">return</span> _name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这样子的话，我们就可以在其他类里：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person *boy = [[Person alloc] init];    </span><br><span class="line">boy.name = <span class="string">@"xiaoming"</span>;   <span class="comment">//等价于：[boy setName:xiaoming];</span></span><br><span class="line"><span class="built_in">NSString</span>  *boyName = boy.name;      <span class="comment">//等价于：boyName = [boy name];</span></span><br></pre></td></tr></table></figure>
<p>这样是不是就和我们定义一个属性一样了呢？</p>
<p>看一些 Objc 的书才知道，在 iOS 刚出现那会儿，我们是需要为输出口同时声明了属性和底层实例变量（实例变量）的，并且要求你必须声明与之对应的实例变量，例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="built_in">NSString</span> *name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br></pre></td></tr></table></figure>
<p>但是，自从苹果将默认编译器从 <strong>GCC</strong> 转换为 <strong>LLVM</strong>(low level virtual machine) 之后，就不再需要为属性声明实例变量了，或者说将属性与实例变量关联起来。</p>
<p>如果 <strong>LLVM</strong> 发现一个没有匹配实例变量的属性，它将自动创建一个以下划线开头的实例变量（这个应该都知道）。</p>
<p>也就是说，<strong>采用 @property 声明的<code>属性</code>，其实就是利用了 <code>getter</code> 和 <code>setter</code> 的方法来对<code>实例变量</code>进行访问修改的而已。</strong></p>
<p>当然采用 @property 声明的<code>属性</code>所对应的<code>实例方法</code>可以手动生成也可以自动生成。</p>
<ul>
<li><p>自动：如果只声明一个属性a，不使用 @synthesize 实现：编译器会使用_a作为属性的实例变量。</p>
</li>
<li><p>主动：</p>
<ul>
<li>如果声明了一个属性a，使用 @synthesize a 进行实现，但是实现过程中没有指定使用的实例变量，则此时编译器会使用a作为属性的实例变量。</li>
<li>如果声明了一个属性a，使用 @synthesize a=_a 进行实现，这个过程已经指定了使用的实例变量：此时会使用指定的实例变量作为属性变量；</li>
</ul>
</li>
</ul>
<p>并且，当我们不去重载 getter 和 setter 方法时，系统会自动为我们生成，而且 setter 的实现还是根据我们的 @property 的关键字来决定，具体可以看一下，我之前写的博客<a href="https://lzcuriosity.github.io/2016/06/17/聊聊那些iOS内存管理的关键字/" target="_blank" rel="external">《聊聊那些iOS内存管理的关键字》</a>,是不是爽到飞起？！</p>
<p>也难怪 iOS5 之后，Apple官方会推荐我们使用<code>属性</code>来暴露<code>实例变量</code>给外界了。</p>
<h2 id="下划线和-点访问"><a href="#下划线和-点访问" class="headerlink" title="_下划线和.点访问"></a>_下划线和.点访问</h2><p>顺着上一个小节的思路，其实这个问题也就很好懂了。</p>
<ul>
<li><p><code>.点访问</code>，例如 self.a,实际上包括了 setter 或者 getter 方法的调用的。而<code>_下划线访问</code>，例如 _a 是获取实例变量。</p>
</li>
<li><p>并且，由于实际 <strong>getter</strong> 和 <strong>setter</strong> 函数，引用计数也会有点区别； 在使用<code>.点访问</code>，例如 self.a时是调用一个 <strong>getter</strong> 方法。会使引用计数加一，而<code>_下划线访问</code>，例如 _a 不会使用引用技术加一的。<strong>setter</strong> 还要根据属性的关键字来定。</p>
</li>
<li><p><code>_下划线访问</code>是获取不到父类的属性，因为它只是对局部变量的访问</p>
</li>
</ul>
<p>所以我感觉使用<code>.点访问</code>是更好的选择，因为这样可以兼容<strong>懒加载</strong>(懒加载的核心就是重载 <strong>setter</strong> 方法)，同时也避免了使用下滑线的时候忽略了调用对象的指针。</p>
<h2 id="instancetype-和-id"><a href="#instancetype-和-id" class="headerlink" title="instancetype 和 id"></a>instancetype 和 id</h2><h3 id="什么是-instancetype"><a href="#什么是-instancetype" class="headerlink" title="什么是 instancetype"></a>什么是 instancetype</h3><p><code>instancetype</code> 是clang 3.5开始，clang 提供的一个关键字，表示某个方法返回的未知类型的 Objective-C 对象。我们都知道未知类型的的对象可以用 <code>id</code> 关键字表示，那为什么还会再有一个 <code>instancetype</code> 呢？</p>
<h3 id="关联返回类型"><a href="#关联返回类型" class="headerlink" title="关联返回类型"></a>关联返回类型</h3><p>根据 Cocoa 的命名规则，满足下述规则的方法：</p>
<ol>
<li><p>类方法中，以alloc或new开头</p>
</li>
<li><p>实例方法中，以autorelease，init，retain或self开头</p>
</li>
</ol>
<p>会返回一个方法所在类类型的对象，这些方法就被称为是<code>关联返回类型</code>的方法。换句话说，这些方法的返回结果以方法所在的类为类型。</p>
<p>例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">id</span>)alloc;</span><br><span class="line">- (<span class="keyword">id</span>)init;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>当我们使用如下方式初始化NSArray时：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = [[<span class="built_in">NSArray</span> alloc] init];</span><br></pre></td></tr></table></figure>
<p>按照 Cocoa 的命名规则，语句[NSArray alloc] 的类型就是 NSArray<em> 因为alloc的返回类型属于关联返回类型。同样，[[NSArray alloc]init] 的返回结果也是 NSArray</em>。</p>
<h3 id="instancetype-的作用"><a href="#instancetype-的作用" class="headerlink" title="instancetype 的作用"></a>instancetype 的作用</h3><p>如果一个不是关联返回类型的方法，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span></span></span><br><span class="line">+ (<span class="keyword">id</span>)constructAnArray;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>当我们使用如下方式初始化NSArray时：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSArray</span> constructAnArray];</span><br></pre></td></tr></table></figure>
<p>根据Cocoa的方法命名规范，得到的返回类型就和方法声明的返回类型一样，是 <code>id</code>。</p>
<p>但是如果使用 <code>instancetype</code> 作为返回类型，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span></span></span><br><span class="line">+ (instancetype)constructAnArray;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>当使用相同方式初始化NSArray时,得到的返回类型和方法所在类的类型相同，是NSArray*!</p>
<p>总结一下，<code>instancetype</code>的作用，就是使那些非关联返回类型的方法返回所在类的类型！</p>
<p>显然<code>instancetype</code>能够确定对象的类型，能够帮助编译器更好的为我们定位代码书写问题，比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[[<span class="built_in">NSArray</span> alloc] init] mediaPlaybackAllowsAirPlay]; <span class="comment">//  "No visible @interface for `NSArray` declares the selector `mediaPlaybackAllowsAirPlay`"</span></span><br><span class="line"></span><br><span class="line">[[<span class="built_in">NSArray</span> array] mediaPlaybackAllowsAirPlay]; <span class="comment">// (No error)</span></span><br></pre></td></tr></table></figure>
<p>上例中第一行代码，由于 [[NSArray alloc]init] 的结果是 NSArray*，这样编译器就能够根据返回的数据类型检测出 NSArray 是否实现 mediaPlaybackAllowsAirPlay 方法。有利于开发者在编译阶段发现错误。</p>
<p>第二行代码，由于array不属于关联返回类型方法，[NSArray array] 返回的是 <strong>id</strong> 类型，编译器不知道id类型的对象是否实现了mediaPlaybackAllowsAirPlay方法，也就不能够替开发者及时发现错误。</p>
<h3 id="instancetype-和-id-的异同"><a href="#instancetype-和-id-的异同" class="headerlink" title="instancetype 和 id 的异同"></a>instancetype 和 id 的异同</h3><ol>
<li><p>相同点</p>
<p> 都可以作为方法的返回类型。</p>
</li>
<li><p>不同点</p>
<p> ①instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象；</p>
<p> ②instancetype只能作为返回值，不能像id那样作为参数或者定义变量，比如下面的写法：</p>
</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//err,expected a type</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(instancetype)value</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是错的，应该写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(id)value</span><br><span class="line">&#123;</span><br><span class="line">    //do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>最近博客更新的有点勤奋啊，哈哈，自己再写的过程中一直会发现自己的一些知识的盲区和遗忘点，自己也有挺大的收获的。接下来想做的是，整理一下以前的代码，开源分享一些自己以前写的小控件。然后就是要期末考试了，哎~</p>

  </section>

  
  

<section class="post-comments">

    <div class="ds-thread" data-thread-key="2016/06/17/我的笔记整理（一）/"></div>

    <script type="text/javascript">
      var duoshuoQuery = {short_name:"lzcuriosity"};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
        || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
    </script> 

</section>


</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
